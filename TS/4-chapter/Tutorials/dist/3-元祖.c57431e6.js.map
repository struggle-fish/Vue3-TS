{"version":3,"sources":["src/基础类型/3-元祖.ts"],"names":[],"mappings":";;AAAA;;;;AAEA,IAAI,CAAmB;AACvB,CAAC,GAAG,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,CAAC;AAEnB;AAEA;AACA;AAEA;AAGA;AAEA;AACA;AACA,CAAC,CAAC,CAAC,CAAC,GAAG,OAAO,CAAC,CAAC;AAEhB,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;AAE9B,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC","file":"3-元祖.c57431e6.js","sourceRoot":"..","sourcesContent":["// 元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组。\n\nlet x: [string, number];\nx = ['hello', 10]; // OK\n\n// x = [10, 'hello']; // Error\n\n// >> 1、当访问一个已知索引的元素，会得到正确的类型：\n// console.log(x[0].substr(1)); // OK\n\n// console.log(x[1].substr(1)); // Error, 'number' does not have 'substr'\n\n\n// >> 2、当访问一个越界的元素\n\n// 长度为 \"2\" 的元组类型 \"[string, number]\" 在索引 \"3\" 处没有元素。\n// TODO: 以下官方说可以，运行的时候提示上面的错误信息\nx[3] = 'world'; // OK, 字符串可以赋值给(string | number)类型\n\nconsole.log(x[5].toString()); // OK, 'string' 和 'number' 都有 toString\n\nx[6] = true; // Error, 布尔不是(string | number)类型\n\n\n\nexport {}"]}