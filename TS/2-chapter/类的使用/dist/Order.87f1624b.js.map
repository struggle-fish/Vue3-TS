{"version":3,"sources":["src/OrderDetail.ts","src/Order.ts"],"names":[],"mappings":";;;;;;;;;IAAqB,WAAW;EAY9B,qBACE,aAAqB,EACrB,WAAmB,EACnB,KAAa,EAAA;IAAA;IAdf,IAAA,CAAA,aAAa,GAAW,CAAC;ACD3B,IAAA,ADEE,IAAA,CAAA,QCFF,GAAA,ADEa,GAAW,IAAI,QCF5B,CAAA,OAAA,CAAA,eAAA,CAAA,CAAA;AAAuC,IAEjC,ADgBF,IAAI,CChBG,ADgBF,aAAa,GAAG,aAAa;ACfpC,IDgBE,IAAI,CAAC,WAAW,GAAG,WAAW;ACfhC,IDgBE,IAAI,CAAC,KAAK,GAAG,KAAK;ACfpB,IDgBE;ACfF,EDiBA;AChBA,EDgBC;ACdD,IDcC;ACbD,IDaC,OAED,oBAAQ;ACZR,MDaE,OAAO,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK;ACZhC,IDaA;ACZA,EDYC;ACXD,EDWC;ACVD,ADUC,eCTQ,OAAe;AAAE,ADlB5B,OAAA,CAAA,OAAA,GAAA,WAAA;ACmBW,ADWX,ICXqB,ADWjB,ECVO,QAAgB,CDUZ,CCTJ,EDSO,GCTM,CDSF,CCRX,UDQsB,CAAC,EAAE,EAAE,CCRS,EAAA,CDQL,EAAE,EAAE,CAAC;AAC/C,ECT+C,KDSxC,CAAC,GAAG,CAAC,WAAW,CAAC,QAAQ,EAAE,EAAE,KAAK,CAAC,CAAC,CAAA;AAE3C,ECfW,IAAA,CAAA,ADeJ,CAAC,GAAG,GCfO,GAAP,GDeQ,ICfD,ODeY,CAAC,KAAK,GAAE,QAAQ,CAAC,CAAA,CAAA;ECdpC,IAAA,CAAA,IAAI,GAAJ,IAAI;EACJ,IAAA,CAAA,QAAQ,GAAR,QAAQ;EACR,IAAA,CAAA,KAAK,GAAL,KAAK;EACL,IAAA,CAAA,gBAAgB,GAAhB,gBAAgB;EAErB;EACA;EACA;EACA;EACA;AACF,CAAC;;AAIL,IAAI,cAAc,GAAG,IAAI,aAAA,CAAA,OAAW,CAAC,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC,CAAC;AACxD,IAAI,cAAc,GAAG,IAAI,aAAA,CAAA,OAAW,CAAC,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC;AAEvD,IAAI,SAAS,GAAG,IAAI,IAAI,CAAC,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;AAChD,IAAI,KAAK,GAAG,IAAI,KAAK,CAAC,CAAC,EAAE,SAAS,EAAE,IAAI,EAAE,OAAO,EAC/C,CAAC,cAAc,EAAE,cAAc,CAAC,CAAC;AAEjC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC","file":"Order.87f1624b.js","sourceRoot":"..","sourcesContent":["export default class OrderDetail {\n  orderDetailId: number = 0\n  productname: string = '没有'\n  price: number\n  // TS4之前针对\n  // 没有初始化的值，也没有在构造函数中明确给这个赋值的一种解决方案\n  // 增加 undefined 类型就可以\n  // count: number | undefined // TS4之前针对\n\n  // 注意这个 定义了一个属性，但是构造函数里没有赋值，getTotal又用到了，使用！\n  count!: number \n\n  constructor(\n    orderDetailId: number,\n    productname: string,\n    price: number,\n    // count: number\n  ) {\n    this.orderDetailId = orderDetailId\n    this.productname = productname\n    this.price = price\n    // this.count = count\n\n  }\n\n  getTotal() {\n    return this.price * this.count\n  }\n}\n\nlet orderDetail = new OrderDetail(12, \"cc\", 30);\nconsole.log(orderDetail.getTotal(), '哈哈哈');//NaN\n\nconsole.log(typeof orderDetail.count, 'jhahha')//undefined","import OrderDetail from './OrderDetail'\n\nclass Order {\n  //订单 Id，订单日期，顾客地址，顾客名，顾客微信，顾客手机号，客服\n  // public orderId: number | undefined\n  // public date: Date | undefined\n  // public custname: string | undefined\n  // public phone: string | undefined\n\n  // // 定义了一个Array数组,Array数组当中的每一个元素都是OrderDetail类型的元素\n  // public orderDetailArray: OrderDetail[] = []\n\n\n  // 给构造器的参数如果加上public,这个参数就变成了一个属性,\n  //  这种简洁写法是两步综合体： \n  //  第一步：定义了一个属性，\n  //  第二步：等于默认构造函数会给这个属性赋值[隐式操作]\n  constructor(\n    public orderId: number, // 这个等于定义加赋值\n    public date: Date,\n    public custname: string,\n    public phone: string,\n    public orderDetailArray: Array<OrderDetail>)\n    {\n      // this.orderId = orderId\n      // this.date = date\n      // this.custname = custname\n      // this.phone = phone\n      // this.orderDetailArray = orderDetailArray\n    }\n\n}\n\nlet orderDetailOne = new OrderDetail(10, \"电视机\", 5000, 3);\nlet orderDetailTwo = new OrderDetail(11, \"桌子\", 2000, 2);\n\nvar orderDate = new Date(2023, 10, 17, 5, 20, 0);\nlet order = new Order(1, orderDate, \"李武\", \"33333\",\n  [orderDetailOne, orderDetailTwo]);\n\n  console.log(order);\n\n\n\n\n\n"]}