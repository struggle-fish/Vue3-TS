{"version":3,"sources":["src/07-静态方法的继承.js"],"names":["RootClass","rootname","People","name","sex","phone","__proto__","count","commonDescribe","console","log","prototype","doEat","people","ChinesePeople","national","call","Object","setPrototypeOf","chinesePeopleTwo"],"mappings":"AAAA,SAASA,SAAS,GAAI,CAEtB;AACAA,SAAS,CAACC,QAAQ,GAAG,UAAU;AAG/B,SAASC,MAAM,CAAEC,IAAI,EAAEC,GAAG,EAAEC,KAAK,EAAE;EAAC;EAClC,IAAI,CAACF,IAAI,GAAGA,IAAI;EAChB,IAAI,CAACC,GAAG,GAAGA,GAAG;EACd,IAAI,CAACC,KAAK,GAAGA,KAAK;AACpB;AACAH,MAAM,CAACI,SAAS,GAAGN,SAAS;AAC5B;;AAEA;AACA;AACAE,MAAM,CAACK,KAAK,GAAG,GAAG,CAAC;AACnBL,MAAM,CAACM,cAAc,GAAG,YAAY;EAAC;EACnCC,OAAO,CAACC,GAAG,CAAC,MAAM,CAAC;AACrB,CAAC;AACD;AACAR,MAAM,CAACS,SAAS,CAACC,KAAK,GAAG,YAAY;EACnCH,OAAO,CAACC,GAAG,CAAC,IAAI,CAACP,IAAI,GAAG,OAAO,CAAC;AAClC,CAAC;AACD,IAAIU,MAAM,GAAG,IAAIX,MAAM,CAAC,OAAO,EAAE,EAAE,EAAE,KAAK,CAAC;AAC3CO,OAAO,CAACC,GAAG,CAAC,SAAS,EAAEG,MAAM,CAAC;AAG9B,SAASC,aAAa,CAAEX,IAAI,EAAEC,GAAG,EAAEC,KAAK,EAAEU,QAAQ,EAAE;EAAC;;EAEnDb,MAAM,CAACc,IAAI,CAAC,IAAI,EAAEb,IAAI,EAAEC,GAAG,EAAEC,KAAK,CAAC;EACnC,IAAI,CAACU,QAAQ,GAAGA,QAAQ,CAAC;AAC3B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;;AAGA;AACA;;AAGA;AACA;AACAE,MAAM,CAACC,cAAc,CAACJ,aAAa,EAAEZ,MAAM,CAAC;;AAE5CO,OAAO,CAACC,GAAG,CAAC,sBAAsB,EAAEI,aAAa,CAACP,KAAK,CAAC;AACxDE,OAAO,CAACC,GAAG,CAAC,yBAAyB,EAAEI,aAAa,CAACb,QAAQ,CAAC;AAE9Da,aAAa,CAACN,cAAc,EAAE;AAC9BC,OAAO,CAACC,GAAG,CAACI,aAAa,CAACP,KAAK,EAAE,SAAS,CAAC;AAE3C,IAAIY,gBAAgB,GAAG,IAAIL,aAAa,CAAC,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,IAAI,CAAC;AACjE;AACAL,OAAO,CAACC,GAAG,CAAC,mBAAmB,EAAES,gBAAgB,CAACP,KAAK,CAAC;AACxDH,OAAO,CAACC,GAAG,CAAC,yBAAyB,EAAES,gBAAgB,CAACZ,KAAK,CAAC","file":"07-静态方法的继承.dae4a87b.js","sourceRoot":"..","sourcesContent":["function RootClass () {\n\n}\nRootClass.rootname = \"rootname\"\n\n\nfunction People (name, sex, phone) {//父类 【父构造函数】\n  this.name = name;\n  this.sex = sex;\n  this.phone = phone;\n}\nPeople.__proto__ = RootClass\n// TS类 双重性质  即是类型【new实例时TS类是类型】 当用TS类直接获取属性时就是对象\n\n//J S函数 双重性质  即是类型【new实例时JS函数也是类型】 当用JS类直接获取属性时就是对象\n//  JS函数为对象时，可以获取哪些属性呢？【包括prototype,__proto__,自己定义的静态属性】\nPeople.count = 300;// 静态属性 相当于TS类中static属性\nPeople.commonDescribe = function () {// 静态方法 相当于TS继承中static方法\n  console.log(\"需要守法\")\n}\n//People.__proto__\nPeople.prototype.doEat = function () {\n  console.log(this.name + \"吃饭...\")\n}\nlet people = new People(\"wangw\", 23, \"111\");\nconsole.log(\"people:\", people)\n\n\nfunction ChinesePeople (name, sex, phone, national) {//ChinesePeople子类【子构造函数】\n\n  People.call(this, name, sex, phone)\n  this.national = national;//民族\n}\n\n// ES6之前的实现\n// 第一种方式 ：函数以对象形式呈现时，上面自有属性就是静态属性，上面自有方法就是静态方法\n// for (let key in People) { // 自有属性 还会查找__proto__指向的对象空间【这里是rootClass函数对象空间】中自有属性\n//   console.log(\"key:\", key); // 静态属性和静态方法\n// }\n\n// for (let key in People) {// 自有属性 还会查找__proto__指向的对象空间【这里是rootClass函数对象空间】中自有属性\n//    if (Object.prototype.hasOwnProperty.call(People, key)) {// 要求返回true的条件是本构造函数的自有属性 不会查找__proto__指向的对象空间【这里是rootClass函数对象空间】中自有属性\n//   //console.log(\"key:\", key);// 静态属性和静态方法\n//   ChinesePeople[key] = People[key]// 子类ChinesePeople继承父类People的静态属性和静态方法\n//   }\n// }\n\n\n// 第二种实现方式 \n// Object.keys(People).forEach((key) => {\n//   ChinesePeople[key] = People[key]\n// })\n\n\n// 第三种实现方式\n//ChinesePeople.__proto__ = People\n\n\n//ES6 第四种实现方式\n// TODO 这样虽然静态属性和方法关联了，但是原型上的又丢了\nObject.setPrototypeOf(ChinesePeople, People)// 最终建立的关系是ChinesePeople.__proto__ = People\n\nconsole.log(\"ChinesePeople.count:\", ChinesePeople.count);\nconsole.log(\"ChinesePeople.rootname:\", ChinesePeople.rootname);\n\nChinesePeople.commonDescribe();\nconsole.log(ChinesePeople.count, '父类的静态方法')\n\nlet chinesePeopleTwo = new ChinesePeople(\"王海\", \"男\", \"1111\", \"汉族\");\n// TODO 原型上的方法缺找不到了\nconsole.log(\"chinesePeopleTwo:\", chinesePeopleTwo.doEat);\nconsole.log(\"chinesePeopleTwo.count:\", chinesePeopleTwo.count);\n\n\n"]}