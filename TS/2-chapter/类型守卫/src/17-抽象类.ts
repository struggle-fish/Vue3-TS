// 一个在任何位置都不能被实例化的类就是一个抽象类【abstract class 】
/*
什么样的类可以被定义为抽象类

从宏观上来说，任何一个实例化后毫无意义的类都可以被定义为抽象类。
比如：我们实例化一个玫瑰花类的对象变量，可以得到一个具体的 玫瑰花 实例对象，
但如果我们实例化一个  Flower  类的对象变量，那世界上有一个叫 花 的对象吗？
很明显没有，所以 Flower 类 可以定义为一个抽象类，但玫瑰花可以定义为具体的类。

抽象类的特点

可以包含只有方法声明的方法【 和方法签名类似，就是多了 abstract 关键字】，
也可以包含实现了具体功能的方法，可以包含构造器，但不能直接实例化一个抽象类，
只能通过子类来实例化。


abstract class 类名
{ 
  可以有 0 到多个抽象方法【只有方法体，没有方法实现的方法】，
  可以有 0 到多个具体方法，可以有构造器，
  可以有 0 到多个实例属性，
  0 到多个静态属性，
  0 到多个静态方法 
}   
单纯从类的定义上来看和普通类没有区别，只是多了可以有 0 到多个抽象方法这一条
，并且不能被实例化。


抽象类相比普通类充当父类给项目带来的好处
好处1：提供统一名称的抽象方法，提高代码的可维护性
抽象类通常用来充当父类，当抽象类把一个方法定义为抽象方法，
那么会强制在所有子类中实现它，防止不同子类的同功能的方法命名不相同，
从而降低项目维护成本。


好处2：防止实例化一个实例化后毫无意义的类。


*/


abstract class People {//抽象类
  constructor() {

  }
  public name!: string
  // 抽象方法
  abstract eat(): void 
  // 抽象方法 特点 1：没有方法体 2：带abstract关键字

  public step() {
    console.log("双腿走路");
  }
}

class AmericanPeople extends People {
  eat(): void {
    throw new Error('Method not implemented.');
  }

  public phone!: string

}


let people: People = new AmericanPeople();


export { }